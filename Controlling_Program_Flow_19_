#peyman Miyandashti 250161
#maximo 3 numeros 
num1=float(input("ingrese el primer numero:"))
num2=float(input("ingrese el segundo numero:"))
num3=float(input("ingrese el tercero numero:"))

if num1>num2:
    if num1>num3:
        max=num1
    else:
        max=num3
else:
    if num2>num3:
        max=num2
    else:
        max=num3
print(f"el numero mayor es :{max}")
##################################################
# peyman Miyandashti 250161
# Advanced Number Analyzer System

import statistics
from typing import List, Tuple, Dict, Any
from dataclasses import dataclass
from enum import Enum
import math

class NumberCategory(Enum):
    """Categories for number analysis"""
    POSITIVE = "Positive"
    NEGATIVE = "Negative"
    ZERO = "Zero"
    EVEN = "Even"
    ODD = "Odd"
    INTEGER = "Integer"
    DECIMAL = "Decimal"
    PRIME = "Prime"
    PERFECT_SQUARE = "Perfect Square"
    ARMSTRONG = "Armstrong Number"

@dataclass
class NumberAnalysis:
    """Data class to store analysis results"""
    numbers: List[float]
    maximum: float
    minimum: float
    average: float
    median: float
    mode: List[float]
    sum_total: float
    range_value: float
    sorted_numbers: List[float]
    categories: Dict[NumberCategory, List[float]]
    statistics: Dict[str, float]

class AdvancedNumberAnalyzer:
    """Advanced number analysis with multiple features"""
    
    def __init__(self):
        self.history = []
    
    def get_numbers(self) -> List[float]:
        """Get numbers from user input with validation"""
        numbers = []
        
        print("\nğŸ“Š NUMBER INPUT OPTIONS:")
        print("1. Enter 3 numbers (original method)")
        print("2. Enter custom number of numbers")
        print("3. Generate random numbers")
        print("4. Use preset numbers")
        
        choice = input("\nChoose input method (1-4): ").strip()
        
        if choice == '1':
            # Original method: exactly 3 numbers
            numbers = self._get_three_numbers()
        
        elif choice == '2':
            # Custom number of numbers
            count = self._get_valid_int("How many numbers do you want to enter? ", min_val=1, max_val=1000)
            numbers = self._get_multiple_numbers(count)
        
        elif choice == '3':
            # Generate random numbers
            count = self._get_valid_int("How many random numbers? ", min_val=1, max_val=1000)
            min_val = self._get_valid_float("Minimum value: ")
            max_val = self._get_valid_float("Maximum value: ", min_val=min_val+1)
            numbers = self._generate_random_numbers(count, min_val, max_val)
        
        elif choice == '4':
            # Use preset numbers
            numbers = self._get_preset_numbers()
        
        else:
            print("Invalid choice. Using default method (3 numbers).")
            numbers = self._get_three_numbers()
        
        return numbers
    
    def _get_three_numbers(self) -> List[float]:
        """Get exactly 3 numbers (original method)"""
        numbers = []
        for i in range(3):
            while True:
                try:
                    num = float(input(f"Ingrese el {self._get_ordinal(i+1)} nÃºmero: "))
                    numbers.append(num)
                    break
                except ValueError:
                    print("âŒ Error: Por favor ingrese un nÃºmero vÃ¡lido.")
        return numbers
    
    def _get_multiple_numbers(self, count: int) -> List[float]:
        """Get multiple numbers from user"""
        numbers = []
        for i in range(count):
            while True:
                try:
                    prompt = f"Ingrese el {self._get_ordinal(i+1)} nÃºmero"
                    if count > 10:
                        prompt = f"Ingrese nÃºmero {i+1} de {count}"
                    num = float(input(f"{prompt}: "))
                    numbers.append(num)
                    break
                except ValueError:
                    print("âŒ Error: Por favor ingrese un nÃºmero vÃ¡lido.")
        return numbers
    
    def _generate_random_numbers(self, count: int, min_val: float, max_val: float) -> List[float]:
        """Generate random numbers within a range"""
        import random
        numbers = [random.uniform(min_val, max_val) for _ in range(count)]
        
        # Round to 2 decimal places for display
        rounded = [round(num, 2) for num in numbers]
        
        print(f"\nğŸ”¢ NÃºmeros aleatorios generados ({count} nÃºmeros entre {min_val} y {max_val}):")
        print(f"   {rounded}")
        
        return numbers
    
    def _get_preset_numbers(self) -> List[float]:
        """Get numbers from preset categories"""
        print("\nğŸ“ PRESET CATEGORIES:")
        presets = {
            '1': ("NÃºmeros enteros positivos", [15, 42, 7, 89, 23]),
            '2': ("NÃºmeros decimales", [3.14, 2.71, 1.618, 0.577, 1.414]),
            '3': ("NÃºmeros negativos", [-5, -12, -3, -8, -1]),
            '4': ("NÃºmeros mixtos", [10, -5, 3.14, 0, -2.5, 7]),
            '5': ("NÃºmeros grandes", [1000, 2500, 1500, 3000, 2000]),
            '6': ("NÃºmeros pequeÃ±os", [0.001, 0.01, 0.1, 1, 10])
        }
        
        for key, (name, nums) in presets.items():
            print(f"{key}. {name}: {nums}")
        
        choice = input("\nChoose preset (1-6): ").strip()
        return presets.get(choice, presets['1'])[1]
    
    def _get_ordinal(self, n: int) -> str:
        """Convert number to Spanish ordinal"""
        ordinals = {
            1: "primer",
            2: "segundo", 
            3: "tercer",
            4: "cuarto",
            5: "quinto",
            6: "sexto",
            7: "sÃ©ptimo",
            8: "octavo",
            9: "noveno",
            10: "dÃ©cimo"
        }
        return ordinals.get(n, f"nÃºmero {n}")
    
    def _get_valid_int(self, prompt: str, min_val: int = 1, max_val: int = 1000) -> int:
        """Get validated integer input"""
        while True:
            try:
                value = int(input(prompt))
                if min_val <= value <= max_val:
                    return value
                else:
                    print(f"âŒ Error: El nÃºmero debe estar entre {min_val} y {max_val}.")
            except ValueError:
                print("âŒ Error: Por favor ingrese un nÃºmero entero vÃ¡lido.")
    
    def _get_valid_float(self, prompt: str, min_val: float = -float('inf')) -> float:
        """Get validated float input"""
        while True:
            try:
                value = float(input(prompt))
                if value > min_val:
                    return value
                else:
                    print(f"âŒ Error: El nÃºmero debe ser mayor que {min_val}.")
            except ValueError:
                print("âŒ Error: Por favor ingrese un nÃºmero vÃ¡lido.")
    
    def analyze_numbers(self, numbers: List[float]) -> NumberAnalysis:
        """Perform comprehensive analysis on numbers"""
        
        # Basic statistics
        maximum = max(numbers)
        minimum = min(numbers)
        average = sum(numbers) / len(numbers)
        sum_total = sum(numbers)
        range_value = maximum - minimum
        
        # Median
        sorted_numbers = sorted(numbers)
        n = len(sorted_numbers)
        if n % 2 == 0:
            median = (sorted_numbers[n//2 - 1] + sorted_numbers[n//2]) / 2
        else:
            median = sorted_numbers[n//2]
        
        # Mode (could be multiple)
        try:
            mode_value = statistics.mode(numbers)
            mode = [mode_value]
        except statistics.StatisticsError:
            # Multiple modes or no unique mode
            freq = {}
            for num in numbers:
                freq[num] = freq.get(num, 0) + 1
            max_freq = max(freq.values())
            mode = [num for num, count in freq.items() if count == max_freq]
        
        # Categorize numbers
        categories = self._categorize_numbers(numbers)
        
        # Advanced statistics
        stats = {
            'variance': statistics.variance(numbers) if len(numbers) > 1 else 0,
            'std_dev': statistics.stdev(numbers) if len(numbers) > 1 else 0,
            'product': math.prod(numbers),
            'geometric_mean': self._geometric_mean(numbers),
            'harmonic_mean': statistics.harmonic_mean(numbers) if all(n > 0 for n in numbers) else None,
            'quadratic_mean': math.sqrt(sum(n*n for n in numbers) / len(numbers)),
            'mid_range': (maximum + minimum) / 2
        }
        
        return NumberAnalysis(
            numbers=numbers,
            maximum=maximum,
            minimum=minimum,
            average=average,
            median=median,
            mode=mode,
            sum_total=sum_total,
            range_value=range_value,
            sorted_numbers=sorted_numbers,
            categories=categories,
            statistics=stats
        )
    
    def _categorize_numbers(self, numbers: List[float]) -> Dict[NumberCategory, List[float]]:
        """Categorize numbers into different groups"""
        categories = {
            NumberCategory.POSITIVE: [],
            NumberCategory.NEGATIVE: [],
            NumberCategory.ZERO: [],
            NumberCategory.EVEN: [],
            NumberCategory.ODD: [],
            NumberCategory.INTEGER: [],
            NumberCategory.DECIMAL: [],
            NumberCategory.PRIME: [],
            NumberCategory.PERFECT_SQUARE: [],
            NumberCategory.ARMSTRONG: []
        }
        
        for num in numbers:
            # Positive/Negative/Zero
            if num > 0:
                categories[NumberCategory.POSITIVE].append(num)
            elif num < 0:
                categories[NumberCategory.NEGATIVE].append(num)
            else:
                categories[NumberCategory.ZERO].append(num)
            
            # Even/Odd (only for integers)
            if num.is_integer():
                categories[NumberCategory.INTEGER].append(num)
                if int(num) % 2 == 0:
                    categories[NumberCategory.EVEN].append(num)
                else:
                    categories[NumberCategory.ODD].append(num)
            else:
                categories[NumberCategory.DECIMAL].append(num)
            
            # Prime check
            if num.is_integer() and num > 1:
                n = int(num)
                is_prime = True
                for i in range(2, int(math.sqrt(n)) + 1):
                    if n % i == 0:
                        is_prime = False
                        break
                if is_prime:
                    categories[NumberCategory.PRIME].append(num)
            
            # Perfect square check
            if num >= 0 and math.isqrt(int(num))**2 == num:
                categories[NumberCategory.PERFECT_SQUARE].append(num)
            
            # Armstrong number check
            if num.is_integer() and num >= 0:
                n_str = str(int(num))
                power = len(n_str)
                if sum(int(digit)**power for digit in n_str) == num:
                    categories[NumberCategory.ARMSTRONG].append(num)
        
        return categories
    
    def _geometric_mean(self, numbers: List[float]) -> float:
        """Calculate geometric mean"""
        product = math.prod(abs(n) for n in numbers)
        return product ** (1/len(numbers))
    
    def find_maximum_advanced(self, numbers: List[float]) -> Dict[str, Any]:
        """Find maximum with additional information"""
        maximum = max(numbers)
        indices = [i for i, num in enumerate(numbers) if num == maximum]
        count = len(indices)
        
        # Find second maximum
        unique_numbers = sorted(set(numbers), reverse=True)
        second_max = unique_numbers[1] if len(unique_numbers) > 1 else None
        
        return {
            'value': maximum,
            'indices': indices,
            'count': count,
            'second_max': second_max,
            'position_in_sorted': len(numbers) - indices[0] if indices else None
        }
    
    def display_analysis(self, analysis: NumberAnalysis):
        """Display comprehensive analysis results"""
        print(f"\n{'='*60}")
        print("ğŸ“Š RESULTADOS DEL ANÃLISIS DE NÃšMEROS")
        print('='*60)
        
        print(f"\nğŸ”¢ NÃºmeros ingresados: {analysis.numbers}")
        print(f"   NÃºmero de elementos: {len(analysis.numbers)}")
        
        print(f"\nğŸ“ˆ ESTADÃSTICAS BÃSICAS:")
        print(f"   â€¢ MÃ¡ximo: {analysis.maximum}")
        print(f"   â€¢ MÃ­nimo: {analysis.minimum}")
        print(f"   â€¢ Promedio: {analysis.average:.4f}")
        print(f"   â€¢ Mediana: {analysis.median}")
        print(f"   â€¢ Moda: {analysis.mode}")
        print(f"   â€¢ Suma total: {analysis.sum_total}")
        print(f"   â€¢ Rango: {analysis.range_value}")
        
        print(f"\nğŸ“Š ESTADÃSTICAS AVANZADAS:")
        for key, value in analysis.statistics.items():
            if value is not None:
                if isinstance(value, float):
                    print(f"   â€¢ {key.replace('_', ' ').title()}: {value:.4f}")
                else:
                    print(f"   â€¢ {key.replace('_', ' ').title()}: {value}")
        
        print(f"\nğŸ“‚ CATEGORÃAS DE NÃšMEROS:")
        for category, nums in analysis.categories.items():
            if nums:
                category_name = category.value
                if category == NumberCategory.ARMSTRONG:
                    category_name = "NÃºmeros de Armstrong"
                elif category == NumberCategory.PERFECT_SQUARE:
                    category_name = "Cuadrados perfectos"
                print(f"   â€¢ {category_name}: {nums}")
        
        print(f"\nğŸ“ˆ NÃšMEROS ORDENADOS:")
        print(f"   Ascendente: {analysis.sorted_numbers}")
        print(f"   Descendente: {list(reversed(analysis.sorted_numbers))}")
        
        # Additional maximum analysis
        max_info = self.find_maximum_advanced(analysis.numbers)
        print(f"\nğŸ¯ INFORMACIÃ“N ADICIONAL DEL MÃXIMO:")
        print(f"   â€¢ Valor mÃ¡ximo: {max_info['value']}")
        print(f"   â€¢ Ocurre {max_info['count']} vez/veces")
        print(f"   â€¢ Posiciones: {[i+1 for i in max_info['indices']]}")
        if max_info['second_max'] is not None:
            print(f"   â€¢ Segundo mÃ¡ximo: {max_info['second_max']}")
    
    def compare_with_previous(self, current_analysis: NumberAnalysis):
        """Compare current analysis with previous one"""
        if len(self.history) < 1:
            return
        
        previous = self.history[-1]
        
        print(f"\n{'='*60}")
        print("ğŸ”„ COMPARACIÃ“N CON EL ANÃLISIS ANTERIOR")
        print('='*60)
        
        comparisons = [
            ("Cantidad de nÃºmeros", len(current_analysis.numbers), len(previous.numbers)),
            ("MÃ¡ximo", current_analysis.maximum, previous.maximum),
            ("MÃ­nimo", current_analysis.minimum, previous.minimum),
            ("Promedio", current_analysis.average, previous.average),
            ("Suma total", current_analysis.sum_total, previous.sum_total)
        ]
        
        for name, current, prev in comparisons:
            diff = current - prev
            change = "â†‘" if diff > 0 else "â†“" if diff < 0 else "â†’"
            print(f"   â€¢ {name}: {current:.2f} vs {prev:.2f} ({change} {diff:+.2f})")
    
    def save_to_history(self, analysis: NumberAnalysis):
        """Save analysis to history"""
        self.history.append(analysis)
        if len(self.history) > 10:  # Keep only last 10 analyses
            self.history.pop(0)
    
    def display_history(self):
        """Display analysis history"""
        if not self.history:
            print("\nğŸ“­ No hay anÃ¡lisis en el historial.")
            return
        
        print(f"\n{'='*60}")
        print("ğŸ“š HISTORIAL DE ANÃLISIS (Ãºltimos 10)")
        print('='*60)
        
        for i, analysis in enumerate(self.history[-10:], 1):
            print(f"\n{i}. NÃºmeros: {analysis.numbers[:5]}{'...' if len(analysis.numbers) > 5 else ''}")
            print(f"   MÃ¡ximo: {analysis.maximum}, MÃ­nimo: {analysis.minimum}, Promedio: {analysis.average:.2f}")

def number_patterns():
    """Generate interesting number patterns"""
    print(f"\n{'='*60}")
    print("ğŸ¯ PATRONES NUMÃ‰RICOS INTERESANTES")
    print('='*60)
    
    # Fibonacci pattern
    print("\nğŸ”¢ Secuencia de Fibonacci (primeros 10):")
    a, b = 0, 1
    fib = []
    for _ in range(10):
        fib.append(a)
        a, b = b, a + b
    print(f"   {fib}")
    
    # Prime numbers
    print("\nğŸ”¢ NÃºmeros primos (primeros 10):")
    primes = []
    num = 2
    while len(primes) < 10:
        if all(num % i != 0 for i in range(2, int(math.sqrt(num)) + 1)):
            primes.append(num)
        num += 1
    print(f"   {primes}")
    
    # Perfect numbers
    print("\nğŸ”¢ NÃºmeros perfectos (primeros 4):")
    perfect_nums = []
    num = 1
    while len(perfect_nums) < 4:
        # Check if number is perfect (sum of proper divisors equals number)
        divisors = [i for i in range(1, num) if num % i == 0]
        if sum(divisors) == num:
            perfect_nums.append(num)
        num += 1
    print(f"   {perfect_nums}")

def main():
    """Main program loop"""
    analyzer = AdvancedNumberAnalyzer()
    
    print("="*60)
    print("SISTEMA AVANZADO DE ANÃLISIS NUMÃ‰RICO")
    print("Peyman Miyandashti 250161")
    print("="*60)
    
    while True:
        print("\nğŸ“‹ MENÃš PRINCIPAL:")
        print("-"*40)
        print("1. Analizar nÃºmeros")
        print("2. Ver historial de anÃ¡lisis")
        print("3. Comparar con anÃ¡lisis anterior")
        print("4. Ver patrones numÃ©ricos")
        print("5. Ejemplo original (3 nÃºmeros)")
        print("6. Tutorial del sistema")
        print("Q. Salir")
        print("-"*40)
        
        choice = input("\nSeleccione una opciÃ³n: ").strip().upper()
        
        if choice == '1':
            # Analyze numbers
            numbers = analyzer.get_numbers()
            analysis = analyzer.analyze_numbers(numbers)
            analyzer.display_analysis(analysis)
            analyzer.save_to_history(analysis)
            
        elif choice == '2':
            # View history
            analyzer.display_history()
            
        elif choice == '3':
            # Compare with previous
            if len(analyzer.history) < 2:
                print("\nâŒ Se necesitan al menos 2 anÃ¡lisis para comparar.")
            else:
                analyzer.compare_with_previous(analyzer.history[-1])
            
        elif choice == '4':
            # Number patterns
            number_patterns()
            
        elif choice == '5':
            # Original example
            print("\n" + "="*60)
            print("EJEMPLO ORIGINAL - MÃXIMO DE 3 NÃšMEROS")
            print('='*60)
            
            num1 = float(input("Ingrese el primer nÃºmero: "))
            num2 = float(input("Ingrese el segundo nÃºmero: "))
            num3 = float(input("Ingrese el tercer nÃºmero: "))
            
            # Original logic
            if num1 > num2:
                if num1 > num3:
                    max_num = num1
                else:
                    max_num = num3
            else:
                if num2 > num3:
                    max_num = num2
                else:
                    max_num = num3
            
            print(f"\nğŸ” Usando la lÃ³gica original:")
            print(f"   NÃºmeros: {num1}, {num2}, {num3}")
            print(f"   El nÃºmero mayor es: {max_num}")
            
            # Also show using max() function
            print(f"\nğŸ” Usando la funciÃ³n max() de Python:")
            print(f"   El nÃºmero mayor es: {max([num1, num2, num3])}")
            
        elif choice == '6':
            # Tutorial
            print(f"\n{'='*60}")
            print("ğŸ“š TUTORIAL DEL SISTEMA")
            print('='*60)
            print("\nEste sistema avanzado de anÃ¡lisis numÃ©rico permite:")
            print("1. Analizar cualquier cantidad de nÃºmeros (no solo 3)")
            print("2. Calcular estadÃ­sticas avanzadas (media, mediana, moda, etc.)")
            print("3. Categorizar nÃºmeros (pares, impares, primos, etc.)")
            print("4. Generar nÃºmeros aleatorios para anÃ¡lisis")
            print("5. Mantener un historial de anÃ¡lisis previos")
            print("6. Comparar diferentes conjuntos de nÃºmeros")
            print("\nğŸ’¡ Consejo: Use la opciÃ³n 1 para el anÃ¡lisis mÃ¡s completo.")
            
        elif choice == 'Q':
            print("\nÂ¡Gracias por usar el Sistema Avanzado de AnÃ¡lisis NumÃ©rico!")
            print("Peyman Miyandashti 250161")
            print("="*60)
            break
            
        else:
            print("âŒ OpciÃ³n no vÃ¡lida. Por favor intente de nuevo.")
        
        # Pause before continuing
        if choice != 'Q':
            input("\nPresione Enter para continuar...")

if __name__ == "__main__":
    main()
#################################################
# peyman Miyandashti 250161
# Advanced Mathematical Operations Module

def number_theory_analysis():
    """Advanced number theory analysis"""
    print(f"\n{'='*60}")
    print("ğŸ”¬ ANÃLISIS AVANZADO DE TEORÃA DE NÃšMEROS")
    print('='*60)
    
    # Greatest Common Divisor (GCD)
    numbers = [48, 180, 72]
    gcd_result = math.gcd(numbers[0], math.gcd(numbers[1], numbers[2]))
    print(f"\nğŸ“ MÃ¡ximo ComÃºn Divisor (MCD):")
    print(f"   NÃºmeros: {numbers}")
    print(f"   MCD: {gcd_result}")
    
    # Least Common Multiple (LCM)
    def lcm(a, b):
        return abs(a * b) // math.gcd(a, b)
    
    lcm_result = lcm(numbers[0], lcm(numbers[1], numbers[2]))
    print(f"\nğŸ“ MÃ­nimo ComÃºn MÃºltiplo (MCM):")
    print(f"   NÃºmeros: {numbers}")
    print(f"   MCM: {lcm_result}")
    
    # Number factorization
    num = 360
    print(f"\nğŸ”¢ FactorizaciÃ³n de {num}:")
    factors = []
    n = num
    divisor = 2
    while n > 1:
        if n % divisor == 0:
            factors.append(divisor)
            n //= divisor
        else:
            divisor += 1
    print(f"   Factores primos: {factors}")
    
    # Sum of digits
    large_num = 123456789
    digit_sum = sum(int(d) for d in str(large_num))
    print(f"\nğŸ”¢ Suma de dÃ­gitos de {large_num}:")
    print(f"   Suma: {digit_sum}")
    
    # Number reversal
    reversed_num = int(str(large_num)[::-1])
    print(f"\nğŸ”¢ NÃºmero invertido:")
    print(f"   Original: {large_num}")
    print(f"   Invertido: {reversed_num}")

def number_conversions():
    """Convert numbers between different bases"""
    print(f"\n{'='*60}")
    print("ğŸ”„ CONVERSIONES DE NÃšMEROS")
    print('='*60)
    
    number = 255
    
    conversions = [
        ("Decimal", str(number)),
        ("Binario", bin(number)),
        ("Hexadecimal", hex(number)),
        ("Octal", oct(number))
    ]
    
    print(f"\nConversiones del nÃºmero {number}:")
    for base, value in conversions:
        print(f"   â€¢ {base}: {value}")
    
    # Custom base conversion
    def to_base(n, base):
        digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        if n == 0:
            return "0"
        result = ""
        while n > 0:
            result = digits[n % base] + result
            n //= base
        return result
    
    print(f"\nConversiones a bases personalizadas:")
    for base in [2, 8, 16, 20, 36]:
        print(f"   â€¢ Base {base:2}: {to_base(number, base)}")

def number_sorting_algorithms():
    """Demonstrate different sorting algorithms"""
    print(f"\n{'='*60}")
    print("ğŸ”¢ ALGORITMOS DE ORDENAMIENTO")
    print('='*60)
    
    numbers = [64, 34, 25, 12, 22, 11, 90]
    print(f"\nNÃºmeros originales: {numbers}")
    
    # Bubble Sort
    def bubble_sort(arr):
        arr_copy = arr.copy()
        n = len(arr_copy)
        for i in range(n-1):
            for j in range(0, n-i-1):
                if arr_copy[j] > arr_copy[j+1]:
                    arr_copy[j], arr_copy[j+1] = arr_copy[j+1], arr_copy[j]
        return arr_copy
    
    # Quick Sort
    def quick_sort(arr):
        if len(arr) <= 1:
            return arr
        pivot = arr[len(arr)//2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quick_sort(left) + middle + quick_sort(right)
    
    print(f"\nğŸ” Bubble Sort: {bubble_sort(numbers)}")
    print(f"âš¡ Quick Sort: {quick_sort(numbers)}")
    print(f"ğŸ“Š Python sorted(): {sorted(numbers)}")

# Run advanced features
if __name__ == "__main__":
    print("\n" + "="*60)
    print("CARACTERÃSTICAS AVANZADAS DE ANÃLISIS NUMÃ‰RICO")
    print("="*60)
    
    number_theory_analysis()
    number_conversions()
    number_sorting_algorithms()
