#peyman miyandashti 250161
# Calculate area of a circle
radius = 5
pi = 3.14159
area = pi * radius ** 2
print(f"The area is {area:.2f}")  # Formatted to 2 decimal places
############################################
# peyman miyandashti 250161

import math
from typing import Union, Tuple, List
from dataclasses import dataclass
from enum import Enum

class ShapeType(Enum):
    """Enum for different shape types"""
    CIRCLE = "Circle"
    RECTANGLE = "Rectangle"
    TRIANGLE = "Triangle"
    SQUARE = "Square"
    SPHERE = "Sphere"
    CYLINDER = "Cylinder"
    CUBE = "Cube"
    PYRAMID = "Pyramid"
    ELLIPSE = "Ellipse"
    POLYGON = "Polygon"
    TRAPEZOID = "Trapezoid"

@dataclass
class GeometryResult:
    """Data class to store geometry calculation results"""
    shape: ShapeType
    area: float
    perimeter: float = 0.0
    volume: float = 0.0
    surface_area: float = 0.0
    properties: dict = None
    
    def display(self):
        """Display the calculation results in a formatted way"""
        print(f"\n{'='*50}")
        print(f"{self.shape.value.upper()} CALCULATIONS")
        print('='*50)
        
        if self.area:
            print(f"üìê Area: {self.area:.4f} square units")
        if self.perimeter:
            print(f"üìè Perimeter: {self.perimeter:.4f} units")
        if self.volume:
            print(f"üì¶ Volume: {self.volume:.4f} cubic units")
        if self.surface_area:
            print(f"üéØ Surface Area: {self.surface_area:.4f} square units")
        
        if self.properties:
            print("\nüìä Properties:")
            for key, value in self.properties.items():
                if isinstance(value, float):
                    print(f"  {key}: {value:.4f}")
                else:
                    print(f"  {key}: {value}")
        
        # Additional interesting facts
        print("\nüí° Interesting Facts:")
        if self.shape == ShapeType.CIRCLE:
            print(f"  ‚Ä¢ Diameter: {self.properties.get('diameter', 0):.4f}")
            print(f"  ‚Ä¢ Circumference: {self.perimeter:.4f}")
            print(f"  ‚Ä¢ œÄ (pi) approximation: {math.pi:.10f}")

class GeometryCalculator:
    """Comprehensive geometry calculator with multiple shapes"""
    
    def __init__(self):
        self.pi = math.pi  # Use math.pi for accuracy
        self.history = []  # Store calculation history
    
    def calculate_circle(self, radius: float) -> GeometryResult:
        """Calculate circle properties"""
        if radius <= 0:
            raise ValueError("Radius must be positive")
        
        area = self.pi * radius ** 2
        circumference = 2 * self.pi * radius
        diameter = 2 * radius
        
        return GeometryResult(
            shape=ShapeType.CIRCLE,
            area=area,
            perimeter=circumference,
            properties={
                'radius': radius,
                'diameter': diameter,
                'pi_used': self.pi
            }
        )
    
    def calculate_rectangle(self, length: float, width: float) -> GeometryResult:
        """Calculate rectangle properties"""
        if length <= 0 or width <= 0:
            raise ValueError("Dimensions must be positive")
        
        area = length * width
        perimeter = 2 * (length + width)
        diagonal = math.sqrt(length ** 2 + width ** 2)
        
        return GeometryResult(
            shape=ShapeType.RECTANGLE,
            area=area,
            perimeter=perimeter,
            properties={
                'length': length,
                'width': width,
                'diagonal': diagonal,
                'aspect_ratio': length / width
            }
        )
    
    def calculate_triangle(self, base: float, height: float, 
                          side_a: float = None, side_b: float = None, side_c: float = None) -> GeometryResult:
        """Calculate triangle properties (various types)"""
        if base <= 0 or height <= 0:
            raise ValueError("Base and height must be positive")
        
        area = 0.5 * base * height
        
        properties = {
            'base': base,
            'height': height,
            'type': 'Right triangle' if side_a and side_b and side_c is None else 'General triangle'
        }
        
        perimeter = 0
        if side_a and side_b and side_c:
            if side_a <= 0 or side_b <= 0 or side_c <= 0:
                raise ValueError("All sides must be positive")
            
            # Use Heron's formula for area if all sides given
            s = (side_a + side_b + side_c) / 2
            area = math.sqrt(s * (s - side_a) * (s - side_b) * (s - side_c))
            perimeter = side_a + side_b + side_c
            
            # Determine triangle type
            sides = sorted([side_a, side_b, side_c])
            if sides[0] + sides[1] <= sides[2]:
                raise ValueError("Invalid triangle sides")
            
            if side_a == side_b == side_c:
                properties['type'] = 'Equilateral'
            elif side_a == side_b or side_a == side_c or side_b == side_c:
                properties['type'] = 'Isosceles'
            else:
                properties['type'] = 'Scalene'
            
            # Check if right triangle
            if math.isclose(sides[0]**2 + sides[1]**2, sides[2]**2, rel_tol=1e-9):
                properties['type'] += ' (Right)'
            
            properties.update({
                'side_a': side_a,
                'side_b': side_b,
                'side_c': side_c,
                'semiperimeter': s
            })
        
        return GeometryResult(
            shape=ShapeType.TRIANGLE,
            area=area,
            perimeter=perimeter,
            properties=properties
        )
    
    def calculate_sphere(self, radius: float) -> GeometryResult:
        """Calculate sphere properties"""
        if radius <= 0:
            raise ValueError("Radius must be positive")
        
        surface_area = 4 * self.pi * radius ** 2
        volume = (4/3) * self.pi * radius ** 3
        
        return GeometryResult(
            shape=ShapeType.SPHERE,
            area=surface_area,  # Surface area
            volume=volume,
            properties={
                'radius': radius,
                'diameter': 2 * radius,
                'great_circle_circumference': 2 * self.pi * radius
            }
        )
    
    def calculate_cylinder(self, radius: float, height: float) -> GeometryResult:
        """Calculate cylinder properties"""
        if radius <= 0 or height <= 0:
            raise ValueError("Radius and height must be positive")
        
        base_area = self.pi * radius ** 2
        lateral_area = 2 * self.pi * radius * height
        surface_area = 2 * base_area + lateral_area
        volume = base_area * height
        
        return GeometryResult(
            shape=ShapeType.CYLINDER,
            area=surface_area,
            volume=volume,
            properties={
                'radius': radius,
                'height': height,
                'base_area': base_area,
                'lateral_area': lateral_area
            }
        )
    
    def calculate_polygon(self, n_sides: int, side_length: float) -> GeometryResult:
        """Calculate regular polygon properties"""
        if n_sides < 3:
            raise ValueError("Polygon must have at least 3 sides")
        if side_length <= 0:
            raise ValueError("Side length must be positive")
        
        # Interior angle
        interior_angle = (n_sides - 2) * 180 / n_sides
        
        # Area of regular polygon
        apothem = side_length / (2 * math.tan(math.pi / n_sides))
        perimeter = n_sides * side_length
        area = 0.5 * perimeter * apothem
        
        return GeometryResult(
            shape=ShapeType.POLYGON,
            area=area,
            perimeter=perimeter,
            properties={
                'number_of_sides': n_sides,
                'side_length': side_length,
                'interior_angle': interior_angle,
                'apothem': apothem,
                'central_angle': 360 / n_sides,
                'name': self._get_polygon_name(n_sides)
            }
        )
    
    def _get_polygon_name(self, n_sides: int) -> str:
        """Get the name of regular polygon based on number of sides"""
        names = {
            3: "Triangle",
            4: "Square",
            5: "Pentagon",
            6: "Hexagon",
            7: "Heptagon",
            8: "Octagon",
            9: "Nonagon",
            10: "Decagon"
        }
        return names.get(n_sides, f"{n_sides}-gon")
    
    def calculate_ellipse(self, major_axis: float, minor_axis: float) -> GeometryResult:
        """Calculate ellipse properties"""
        if major_axis <= 0 or minor_axis <= 0:
            raise ValueError("Axes must be positive")
        
        area = self.pi * major_axis * minor_axis
        
        # Approximation for perimeter (Ramanujan's formula)
        h = ((major_axis - minor_axis) ** 2) / ((major_axis + minor_axis) ** 2)
        perimeter = self.pi * (major_axis + minor_axis) * (1 + (3*h)/(10 + math.sqrt(4 - 3*h)))
        
        eccentricity = math.sqrt(1 - (minor_axis ** 2) / (major_axis ** 2)) if major_axis >= minor_axis else 0
        
        return GeometryResult(
            shape=ShapeType.ELLIPSE,
            area=area,
            perimeter=perimeter,
            properties={
                'major_axis': major_axis,
                'minor_axis': minor_axis,
                'eccentricity': eccentricity,
                'foci_distance': 2 * math.sqrt(abs(major_axis**2 - minor_axis**2))
            }
        )
    
    def calculate_cube(self, side: float) -> GeometryResult:
        """Calculate cube properties"""
        if side <= 0:
            raise ValueError("Side must be positive")
        
        surface_area = 6 * side ** 2
        volume = side ** 3
        space_diagonal = side * math.sqrt(3)
        
        return GeometryResult(
            shape=ShapeType.CUBE,
            area=surface_area,
            volume=volume,
            properties={
                'side': side,
                'face_diagonal': side * math.sqrt(2),
                'space_diagonal': space_diagonal,
                'face_area': side ** 2
            }
        )
    
    def save_to_history(self, result: GeometryResult):
        """Save calculation to history"""
        self.history.append(result)
        if len(self.history) > 10:  # Keep only last 10 calculations
            self.history.pop(0)
    
    def display_history(self):
        """Display calculation history"""
        if not self.history:
            print("\nNo calculations in history.")
            return
        
        print(f"\n{'='*50}")
        print("CALCULATION HISTORY (Last 10)")
        print('='*50)
        
        for i, result in enumerate(self.history[-10:], 1):
            print(f"{i}. {result.shape.value}: Area={result.area:.2f}, "
                  f"Perimeter={result.perimeter:.2f}, Volume={result.volume:.2f}")

def display_menu():
    """Display the main menu"""
    print("\n" + "="*60)
    print("GEOMETRY CALCULATOR SUITE")
    print("Peyman Miyandashti 250161")
    print("="*60)
    print("\nüìê AVAILABLE SHAPES:")
    print("-"*40)
    
    shapes = [
        ("1", "Circle", "radius"),
        ("2", "Rectangle", "length, width"),
        ("3", "Triangle", "base, height, sides (optional)"),
        ("4", "Sphere", "radius"),
        ("5", "Cylinder", "radius, height"),
        ("6", "Polygon (Regular)", "number of sides, side length"),
        ("7", "Ellipse", "major axis, minor axis"),
        ("8", "Cube", "side length"),
        ("9", "Square", "side length"),
        ("10", "Trapezoid", "base1, base2, height"),
        ("H", "View History", ""),
        ("C", "Clear History", ""),
        ("Q", "Quit", "")
    ]
    
    for num, name, params in shapes:
        if params:
            print(f"{num:>2}. {name:20} ({params})")
        else:
            print(f"{num:>2}. {name}")
    
    print("-"*40)

def get_float_input(prompt: str, min_val: float = 0, allow_zero: bool = False) -> float:
    """Get validated float input from user"""
    while True:
        try:
            value = float(input(prompt))
            if value < min_val:
                print(f"Value must be at least {min_val}")
            elif not allow_zero and value == 0:
                print("Value cannot be zero")
            else:
                return value
        except ValueError:
            print("Please enter a valid number")

def main():
    """Main program loop"""
    calculator = GeometryCalculator()
    
    while True:
        display_menu()
        choice = input("\nEnter your choice: ").strip().upper()
        
        try:
            if choice == '1':  # Circle
                radius = get_float_input("Enter radius: ", min_val=0.0001)
                result = calculator.calculate_circle(radius)
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '2':  # Rectangle
                length = get_float_input("Enter length: ", min_val=0.0001)
                width = get_float_input("Enter width: ", min_val=0.0001)
                result = calculator.calculate_rectangle(length, width)
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '3':  # Triangle
                print("\nTriangle calculation options:")
                print("1. Base and height (area only)")
                print("2. All three sides (area and perimeter)")
                
                tri_choice = input("Choose option (1 or 2): ").strip()
                
                if tri_choice == '1':
                    base = get_float_input("Enter base: ", min_val=0.0001)
                    height = get_float_input("Enter height: ", min_val=0.0001)
                    result = calculator.calculate_triangle(base, height)
                elif tri_choice == '2':
                    side_a = get_float_input("Enter side A: ", min_val=0.0001)
                    side_b = get_float_input("Enter side B: ", min_val=0.0001)
                    side_c = get_float_input("Enter side C: ", min_val=0.0001)
                    result = calculator.calculate_triangle(
                        base=side_a, height=0,  # Height calculated internally
                        side_a=side_a, side_b=side_b, side_c=side_c
                    )
                else:
                    print("Invalid choice")
                    continue
                
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '4':  # Sphere
                radius = get_float_input("Enter radius: ", min_val=0.0001)
                result = calculator.calculate_sphere(radius)
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '5':  # Cylinder
                radius = get_float_input("Enter radius: ", min_val=0.0001)
                height = get_float_input("Enter height: ", min_val=0.0001)
                result = calculator.calculate_cylinder(radius, height)
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '6':  # Polygon
                n_sides = int(get_float_input("Enter number of sides (‚â•3): ", min_val=3))
                side_length = get_float_input("Enter side length: ", min_val=0.0001)
                result = calculator.calculate_polygon(n_sides, side_length)
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '7':  # Ellipse
                major = get_float_input("Enter major axis: ", min_val=0.0001)
                minor = get_float_input("Enter minor axis: ", min_val=0.0001)
                result = calculator.calculate_ellipse(major, minor)
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '8':  # Cube
                side = get_float_input("Enter side length: ", min_val=0.0001)
                result = calculator.calculate_cube(side)
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '9':  # Square (special case of rectangle)
                side = get_float_input("Enter side length: ", min_val=0.0001)
                result = calculator.calculate_rectangle(side, side)
                result.shape = ShapeType.SQUARE
                result.display()
                calculator.save_to_history(result)
            
            elif choice == '10':  # Trapezoid
                base1 = get_float_input("Enter first base: ", min_val=0.0001)
                base2 = get_float_input("Enter second base: ", min_val=0.0001)
                height = get_float_input("Enter height: ", min_val=0.0001)
                # Trapezoid area = (base1 + base2) * height / 2
                area = (base1 + base2) * height / 2
                result = GeometryResult(
                    shape=ShapeType.TRAPEZOID,
                    area=area,
                    properties={
                        'base1': base1,
                        'base2': base2,
                        'height': height,
                        'midsegment': (base1 + base2) / 2
                    }
                )
                result.display()
                calculator.save_to_history(result)
            
            elif choice == 'H':  # History
                calculator.display_history()
            
            elif choice == 'C':  # Clear History
                calculator.history.clear()
                print("\nHistory cleared!")
            
            elif choice == 'Q':  # Quit
                print("\nThank you for using Geometry Calculator!")
                print("Peyman Miyandashti 250161")
                break
            
            else:
                print("Invalid choice. Please try again.")
        
        except ValueError as e:
            print(f"‚ùå Error: {e}")
        except Exception as e:
            print(f"‚ùå Unexpected error: {e}")
        
        # Ask if user wants to continue
        if choice != 'Q':
            input("\nPress Enter to continue...")

if __name__ == "__main__":
    main()
#########################################################################
# peyman miyandashti 250161
# Advanced Geometry Features Module

import numpy as np
from matplotlib import pyplot as plt
import sympy as sp

class AdvancedGeometry:
    """Advanced geometry operations with visualization and symbolic math"""
    
    @staticmethod
    def distance_between_points(p1, p2):
        """Calculate distance between two points in n-dimensional space"""
        p1, p2 = np.array(p1), np.array(p2)
        return np.linalg.norm(p1 - p2)
    
    @staticmethod
    def line_equation(p1, p2):
        """Find equation of line passing through two points"""
        x1, y1 = p1
        x2, y2 = p2
        
        if x1 == x2:
            return f"x = {x1}"  # Vertical line
        
        m = (y2 - y1) / (x2 - x1)
        b = y1 - m * x1
        
        if b >= 0:
            return f"y = {m:.2f}x + {b:.2f}"
        else:
            return f"y = {m:.2f}x - {abs(b):.2f}"
    
    @staticmethod
    def plot_circle(radius, center=(0, 0)):
        """Visualize a circle"""
        theta = np.linspace(0, 2*np.pi, 100)
        x = center[0] + radius * np.cos(theta)
        y = center[1] + radius * np.sin(theta)
        
        plt.figure(figsize=(6, 6))
        plt.plot(x, y, 'b-', linewidth=2)
        plt.scatter([center[0]], [center[1]], color='red', s=100, label='Center')
        plt.axhline(y=0, color='k', linestyle=':', alpha=0.3)
        plt.axvline(x=0, color='k', linestyle=':', alpha=0.3)
        plt.axis('equal')
        plt.grid(True, alpha=0.3)
        plt.title(f'Circle: Radius = {radius}')
        plt.legend()
        plt.show()
    
    @staticmethod
    def symbolic_geometry():
        """Use symbolic math for geometry proofs"""
        # Define symbolic variables
        r = sp.symbols('r', positive=True)
        h = sp.symbols('h', positive=True)
        
        # Circle area formula
        circle_area = sp.pi * r**2
        
        # Cylinder volume formula
        cylinder_volume = sp.pi * r**2 * h
        
        # Sphere volume formula
        sphere_volume = (4/3) * sp.pi * r**3
        
        print("Symbolic Geometry Formulas:")
        print(f"Circle Area: {circle_area}")
        print(f"Cylinder Volume: {cylinder_volume}")
        print(f"Sphere Volume: {sphere_volume}")
        
        return circle_area, cylinder_volume, sphere_volume
    
    @staticmethod
    def golden_ratio_properties():
        """Calculate golden ratio properties"""
        phi = (1 + math.sqrt(5)) / 2  # Golden ratio
        
        golden_rectangle = {
            'ratio': phi,
            'if_width_1': {
                'height': 1/phi,
                'area': 1/phi,
                'diagonal': math.sqrt(1 + (1/phi)**2)
            },
            'if_height_1': {
                'width': phi,
                'area': phi,
                'diagonal': math.sqrt(phi**2 + 1)
            }
        }
        
        return phi, golden_rectangle
    
    @staticmethod
    def fractal_dimension():
        """Calculate fractal dimensions for various shapes"""
        fractals = {
            'Koch Snowflake': {
                'similarity_ratio': 1/3,
                'num_pieces': 4,
                'dimension': math.log(4) / math.log(3)
            },
            'Sierpinski Triangle': {
                'similarity_ratio': 1/2,
                'num_pieces': 3,
                'dimension': math.log(3) / math.log(2)
            },
            'Menger Sponge': {
                'similarity_ratio': 1/3,
                'num_pieces': 20,
                'dimension': math.log(20) / math.log(3)
            }
        }
        return fractals

def geometry_quiz():
    """Interactive geometry quiz"""
    questions = [
        {
            'question': "What is the area of a circle with radius 7?",
            'answer': math.pi * 49,
            'hint': "Use A = œÄr¬≤"
        },
        {
            'question': "What is the volume of a sphere with radius 5?",
            'answer': (4/3) * math.pi * 125,
            'hint': "Use V = (4/3)œÄr¬≥"
        },
        {
            'question': "What is the diagonal of a rectangle with sides 3 and 4?",
            'answer': 5,
            'hint': "Use Pythagorean theorem"
        }
    ]
    
    score = 0
    for i, q in enumerate(questions, 1):
        print(f"\nQuestion {i}: {q['question']}")
        try:
            answer = float(input("Your answer: "))
            if math.isclose(answer, q['answer'], rel_tol=0.01):
                print("‚úÖ Correct!")
                score += 1
            else:
                print(f"‚ùå Incorrect. Hint: {q['hint']}")
                print(f"Correct answer: {q['answer']:.2f}")
        except:
            print("Invalid input")
    
    print(f"\nYour score: {score}/{len(questions)}")

# Run advanced features
if __name__ == "__main__":
    print("\n" + "="*60)
    print("ADVANCED GEOMETRY FEATURES")
    print("="*60)
    
    adv = AdvancedGeometry()
    
    # Calculate distance
    p1 = (1, 2)
    p2 = (4, 6)
    print(f"\nDistance between {p1} and {p2}: {adv.distance_between_points(p1, p2):.2f}")
    
    # Line equation
    print(f"Line equation: {adv.line_equation(p1, p2)}")
    
    # Golden ratio
    phi, golden_props = adv.golden_ratio_properties()
    print(f"\nGolden Ratio (œÜ): {phi:.6f}")
    print(f"Golden Rectangle properties: {golden_props['if_width_1']}")
    
    # Fractal dimensions
    fractals = adv.fractal_dimension()
    print(f"\nFractal Dimensions:")
    for name, props in fractals.items():
        print(f"  {name}: {props['dimension']:.4f}")
    
    # Run quiz
    print("\n" + "="*60)
    print("GEOMETRY QUIZ TIME!")
    print("="*60)
    geometry_quiz()
#########################################################################################
#Peyman Miyandashti #250161
"""
C√ÅLCULO DIFERENCIAL
Ingenier√≠a en Tecnolog√≠as de la Informaci√≥n

M√≥dulo que contiene herramientas fundamentales de c√°lculo diferencial
para aplicaciones en ingenier√≠a de tecnolog√≠as de la informaci√≥n.
Incluye constantes matem√°ticas, derivadas, l√≠mites y aplicaciones pr√°cticas.
"""

import math
import numpy as np
import matplotlib.pyplot as plt
from typing import Callable, List, Tuple, Dict

# =============================================================================
# CONSTANTES MATEM√ÅTICAS FUNDAMENTALES
# =============================================================================
PI = 3.141592653589793
E = 2.718281828459045
GRAVEDAD_TIERRA = 9.81  # m/s¬≤

# =============================================================================
# CLASE PRINCIPAL: CALCULADORA DIFERENCIAL
# =============================================================================
class CalculadoraDiferencial:
    """
    Clase para realizar operaciones de c√°lculo diferencial con aplicaciones
    en ingenier√≠a de tecnolog√≠as de la informaci√≥n.
    """
    
    def __init__(self, precision: int = 6):
        """
        Inicializa la calculadora con una precisi√≥n espec√≠fica.
        
        Args:
            precision (int): N√∫mero de decimales para redondeo (default: 6)
        """
        self.precision = precision
    
    # -------------------------------------------------------------------------
    # L√çMITES Y CONTINUIDAD
    # -------------------------------------------------------------------------
    def limite(self, funcion: Callable[[float], float], punto: float, h: float = 1e-6) -> float:
        """
        Calcula el l√≠mite de una funci√≥n en un punto usando aproximaci√≥n.
        
        Args:
            funcion: Funci√≥n de la cual calcular el l√≠mite
            punto (float): Punto donde evaluar el l√≠mite
            h (float): Incremento infinitesimal (default: 1e-6)
            
        Returns:
            float: Valor del l√≠mite
        """
        try:
            return round((funcion(punto + h) + funcion(punto - h)) / 2, self.precision)
        except ZeroDivisionError:
            return self._limite_indeterminado(funcion, punto, h)
    
    def _limite_indeterminado(self, funcion: Callable[[float], float], punto: float, h: float) -> float:
        """
        Maneja l√≠mites indeterminados usando aproximaci√≥n num√©rica.
        
        Args:
            funcion: Funci√≥n a evaluar
            punto (float): Punto donde evaluar el l√≠mite
            h (float): Incremento infinitesimal
            
        Returns:
            float: Valor aproximado del l√≠mite
        """
        # Estrategia para l√≠mites indeterminados: evaluar desde ambos lados
        izquierda = funcion(punto - h)
        derecha = funcion(punto + h)
        
        if abs(izquierda - derecha) < 1e-10:  # Los valores son muy cercanos
            return round((izquierda + derecha) / 2, self.precision)
        else:
            # Si hay discrepancia, podr√≠a ser un l√≠mite que no existe
            raise ValueError("El l√≠mite podr√≠a no existir en el punto dado")
    
    # -------------------------------------------------------------------------
    # DERIVADAS
    # -------------------------------------------------------------------------
    def derivada(self, funcion: Callable[[float], float], x: float, h: float = 1e-6) -> float:
        """
        Calcula la derivada de una funci√≥n en un punto usando diferencia central.
        
        Args:
            funcion: Funci√≥n a derivar
            x (float): Punto donde calcular la derivada
            h (float): Incremento infinitesimal (default: 1e-6)
            
        Returns:
            float: Valor de la derivada en el punto x
        """
        try:
            return round((funcion(x + h) - funcion(x - h)) / (2 * h), self.precision)
        except ZeroDivisionError:
            raise ValueError("Divisi√≥n por cero al calcular la derivada")
    
    def derivada_segunda(self, funcion: Callable[[float], float], x: float, h: float = 1e-6) -> float:
        """
        Calcula la segunda derivada de una funci√≥n en un punto.
        
        Args:
            funcion: Funci√≥n a derivar
            x (float): Punto donde calcular la derivada
            h (float): Incremento infinitesimal (default: 1e-6)
            
        Returns:
            float: Valor de la segunda derivada en el punto x
        """
        try:
            return round((funcion(x + h) - 2 * funcion(x) + funcion(x - h)) / (h ** 2), self.precision)
        except ZeroDivisionError:
            raise ValueError("Divisi√≥n por cero al calcular la segunda derivada")
    
    def derivada_n_esima(self, funcion: Callable[[float], float], x: float, n: int, h: float = 1e-4) -> float:
        """
        Calcula la n-√©sima derivada de una funci√≥n usando diferencias finitas.
        
        Args:
            funcion: Funci√≥n a derivar
            x (float): Punto donde calcular la derivada
            n (int): Orden de la derivada
            h (float): Incremento infinitesimal (default: 1e-4)
            
        Returns:
            float: Valor de la n-√©sima derivada
        """
        if n == 0:
            return round(funcion(x), self.precision)
        
        if n == 1:
            return self.derivada(funcion, x, h)
        else:
            # Aproximaci√≥n para derivadas de orden superior
            return round((self.derivada_n_esima(funcion, x + h, n - 1, h) - 
                         self.derivada_n_esima(funcion, x - h, n - 1, h)) / (2 * h), self.precision)
    
    # -------------------------------------------------------------------------
    # REGLAS DE DERIVACI√ìN
    # -------------------------------------------------------------------------
    def regla_producto(self, f: Callable[[float], float], g: Callable[[float], float], 
                       x: float, h: float = 1e-6) -> float:
        """
        Aplica la regla del producto para derivadas: (fg)' = f'g + fg'
        
        Args:
            f: Primera funci√≥n
            g: Segunda funci√≥n
            x (float): Punto de evaluaci√≥n
            h (float): Incremento infinitesimal
            
        Returns:
            float: Derivada del producto en x
        """
        f_val = f(x)
        g_val = g(x)
        f_prime = self.derivada(f, x, h)
        g_prime = self.derivada(g, x, h)
        
        return round(f_prime * g_val + f_val * g_prime, self.precision)
    
    def regla_cociente(self, f: Callable[[float], float], g: Callable[[float], float], 
                       x: float, h: float = 1e-6) -> float:
        """
        Aplica la regla del cociente para derivadas: (f/g)' = (f'g - fg')/g¬≤
        
        Args:
            f: Funci√≥n numerador
            g: Funci√≥n denominador
            x (float): Punto de evaluaci√≥n
            h (float): Incremento infinitesimal
            
        Returns:
            float: Derivada del cociente en x
        """
        f_val = f(x)
        g_val = g(x)
        f_prime = self.derivada(f, x, h)
        g_prime = self.derivada(g, x, h)
        
        if abs(g_val) < 1e-12:
            raise ValueError("Divisi√≥n por cero: el denominador no puede ser cero")
        
        return round((f_prime * g_val - f_val * g_prime) / (g_val ** 2), self.precision)
    
    def regla_cadena(self, f: Callable[[float], float], g: Callable[[float], float], 
                     x: float, h: float = 1e-6) -> float:
        """
        Aplica la regla de la cadena para derivadas: (f‚àòg)' = f'(g(x)) * g'(x)
        
        Args:
            f: Funci√≥n exterior
            g: Funci√≥n interior
            x (float): Punto de evaluaci√≥n
            h (float): Incremento infinitesimal
            
        Returns:
            float: Derivada de la composici√≥n en x
        """
        g_val = g(x)
        f_prime_g = self.derivada(f, g_val, h)
        g_prime = self.derivada(g, x, h)
        
        return round(f_prime_g * g_prime, self.precision)
    
    # -------------------------------------------------------------------------
    # APLICACIONES PR√ÅCTICAS PARA TI
    # -------------------------------------------------------------------------
    def velocidad_instantanea(self, funcion_posicion: Callable[[float], float], 
                             tiempo: float, h: float = 1e-6) -> float:
        """
        Calcula la velocidad instant√°nea como derivada de la posici√≥n.
        
        Args:
            funcion_posicion: Funci√≥n que describe la posici√≥n en el tiempo
            tiempo (float): Instante de tiempo
            h (float): Incremento infinitesimal
            
        Returns:
            float: Velocidad instant√°nea
        """
        return self.derivada(funcion_posicion, tiempo, h)
    
    def aceleracion_instantanea(self, funcion_posicion: Callable[[float], float], 
                               tiempo: float, h: float = 1e-6) -> float:
        """
        Calcula la aceleraci√≥n instant√°nea como segunda derivada de la posici√≥n.
        
        Args:
            funcion_posicion: Funci√≥n que describe la posici√≥n en el tiempo
            tiempo (float): Instante de tiempo
            h (float): Incremento infinitesimal
            
        Returns:
            float: Aceleraci√≥n instant√°nea
        """
        return self.derivada_segunda(funcion_posicion, tiempo, h)
    
    def tasa_cambio(self, funcion: Callable[[float], float], x: float, h: float = 1e-6) -> float:
        """
        Calcula la tasa de cambio instant√°nea de una funci√≥n.
        
        Args:
            funcion: Funci√≥n a analizar
            x (float): Punto de evaluaci√≥n
            h (float): Incremento infinitesimal
            
        Returns:
            float: Tasa de cambio instant√°nea
        """
        return self.derivada(funcion, x, h)
    
    def optimizar_funcion(self, funcion: Callable[[float], float], 
                         a: float, b: float, paso: float = 0.01) -> Dict[str, List[Tuple[float, float]]]:
        """
        Encuentra m√≠nimos y m√°ximos locales en un intervalo [a, b].
        
        Args:
            funcion: Funci√≥n a optimizar
            a (float): L√≠mite inferior del intervalo
            b (float): L√≠mite superior del intervalo
            paso (float): Paso para el barrido (default: 0.01)
            
        Returns:
            dict: Puntos cr√≠ticos encontrados con su tipo y coordenadas
        """
        puntos_criticos = {'minimos': [], 'maximos': [], 'puntos_inflexion': []}
        x = a
        
        while x <= b:
            try:
                derivada1 = self.derivada(funcion, x)
                derivada2 = self.derivada_segunda(funcion, x)
                
                if abs(derivada1) < 1e-5:  # Punto cr√≠tico
                    if derivada2 > 1e-5:  # M√≠nimo local
                        puntos_criticos['minimos'].append((round(x, 3), round(funcion(x), 3)))
                    elif derivada2 < -1e-5:  # M√°ximo local
                        puntos_criticos['maximos'].append((round(x, 3), round(funcion(x), 3)))
                    else:  # Posible punto de inflexi√≥n
                        puntos_criticos['puntos_inflexion'].append((round(x, 3), round(funcion(x), 3)))
            except:
                # Saltar puntos problem√°ticos
                pass
            
            x += paso
        
        return puntos_criticos
    
    def graficar_funcion_y_derivada(self, funcion: Callable[[float], float], 
                                   a: float, b: float, titulo: str = "Funci√≥n y su derivada"):
        """
        Grafica una funci√≥n y su derivada en un intervalo [a, b].
        
        Args:
            funcion: Funci√≥n a graficar
            a (float): L√≠mite inferior del intervalo
            b (float): L√≠mite superior del intervalo
            titulo (str): T√≠tulo del gr√°fico
        """
        x_vals = np.linspace(a, b, 1000)
        y_vals = [funcion(x) for x in x_vals]
        dy_vals = [self.derivada(funcion, x) for x in x_vals]
        
        plt.figure(figsize=(10, 6))
        plt.plot(x_vals, y_vals, label='Funci√≥n', linewidth=2)
        plt.plot(x_vals, dy_vals, label='Derivada', linewidth=2)
        plt.title(titulo)
        plt.xlabel('x')
        plt.ylabel('y')
        plt.legend()
        plt.grid(True, alpha=0.3)
        plt.show()

# =============================================================================
# FUNCIONES MATEM√ÅTICAS COMUNES
# =============================================================================
def funcion_lineal(x: float, m: float = 2, b: float = 1) -> float:
    """Funci√≥n lineal: f(x) = m*x + b"""
    return m * x + b

def funcion_cuadratica(x: float, a: float = 1, b: float = 0, c: float = 0) -> float:
    """Funci√≥n cuadr√°tica: f(x) = a*x¬≤ + b*x + c"""
    return a * x**2 + b * x + c

def funcion_exponencial(x: float, base: float = E) -> float:
    """Funci√≥n exponencial: f(x) = base^x"""
    return base ** x

def funcion_logaritmica(x: float, base: float = E) -> float:
    """Funci√≥n logar√≠tmica: f(x) = log_base(x)"""
    if x <= 0:
        return float('-inf')
    return math.log(x, base)

def funcion_seno(x: float) -> float:
    """Funci√≥n trigonom√©trica seno: f(x) = sin(x)"""
    return math.sin(x)

def funcion_coseno(x: float) -> float:
    """Funci√≥n trigonom√©trica coseno: f(x) = cos(x)"""
    return math.cos(x)

def funcion_sigmoide(x: float) -> float:
    """
    Funci√≥n sigmoide, com√∫nmente usada en redes neuronales.
    f(x) = 1 / (1 + e^(-x))
    """
    return 1 / (1 + math.exp(-x))

# =============================================================================
# EJEMPLOS DE USO Y DEMOSTRACI√ìN
# =============================================================================
if __name__ == "__main__":
    # Crear instancia de la calculadora
    calc = CalculadoraDiferencial(precision=4)
    
    print("=" * 70)
    print("C√ÅLCULO DIFERENCIAL - INGENIER√çA EN TECNOLOG√çAS DE LA INFORMACI√ìN")
    print("=" * 70)
    
    # Ejemplo 1: Derivada de funci√≥n cuadr√°tica
    print("\n1. DERIVADA DE FUNCI√ìN CUADR√ÅTICA")
    print("   f(x) = x¬≤ + 2x + 1")
    resultado = calc.derivada(lambda x: x**2 + 2*x + 1, 2)
    print(f"   f'(2) = {resultado}")
    
    # Ejemplo 2: Velocidad instant√°nea
    print("\n2. VELOCIDAD INSTANT√ÅNEA")
    # Posici√≥n: s(t) = t¬≥ - 2t¬≤ + 3t
    posicion = lambda t: t**3 - 2*t**2 + 3*t
    velocidad = calc.velocidad_instantanea(posicion, 2)
    print(f"   s(t) = t¬≥ - 2t¬≤ + 3t")
    print(f"   v(2) = {velocidad} m/s")
    
    # Ejemplo 3: Optimizaci√≥n
    print("\n3. OPTIMIZACI√ìN - M√çNIMOS Y M√ÅXIMOS")
    funcion = lambda x: x**3 - 6*x**2 + 9*x + 1
    optimos = calc.optimizar_funcion(funcion, 0, 4)
    print(f"   f(x) = x¬≥ - 6x¬≤ + 9x + 1")
    print(f"   M√≠nimos: {optimos['minimos']}")
    print(f"   M√°ximos: {optimos['maximos']}")
    print(f"   Puntos de inflexi√≥n: {optimos['puntos_inflexion']}")
    
    # Ejemplo 4: Reglas de derivaci√≥n
    print("\n4. REGLA DEL PRODUCTO")
    f = lambda x: x**2
    g = lambda x: math.sin(x)
    producto = calc.regla_producto(f, g, PI/2)
    print(f"   f(x) = x¬≤, g(x) = sin(x)")
    print(f"   (f¬∑g)'({PI/2:.2f}) = {producto}")
    
    # Ejemplo 5: Aplicaci√≥n en machine learning (derivada de sigmoide)
    print("\n5. APLICACI√ìN EN MACHINE LEARNING: DERIVADA DE SIGMOIDE")
    sigmoide = lambda x: 1 / (1 + math.exp(-x))
    derivada_sigmoide = calc.derivada(sigmoide, 0)
    print(f"   œÉ(0) = {sigmoide(0):.4f}")
    print(f"   œÉ'(0) = {derivada_sigmoide:.4f}")
    
    # Ejemplo 6: Gr√°fico de funci√≥n y su derivada
    print("\n6. GR√ÅFICO DE FUNCI√ìN Y SU DERIVADA")
    print("   Generando gr√°fico para f(x) = x¬≥ - 6x¬≤ + 9x + 1...")
    calc.graficar_funcion_y_derivada(funcion, 0, 4, "Funci√≥n c√∫bica y su derivada")
    
    print("\n" + "=" * 70)

